# Timing Paper Outline

## Introduction
**Problem**: Not all WCET analysis provides guarantees, even the ones that do may not be very precise. WCET analysis cannot discover timing attack vulnerabilities

**Goal**: be able to formally prove the timing behavior of a program, namely its responsiveness or immunity to timing attacks

**Contributions**:
- Picinae Timing Module - Generic extension to the Picinae binary verification system for trace-based timing verification of binary code
    + RISC-V timing module
    + NEORV32 instantiation of the RISC-V timing module
- Automation
    + `hammer` tactic for solving `cycle_count_of_trace` goals
    + Tactics like `compare_sums` for debugging `cycle_count_of_trace` goals
    + Timing Invariant Generator (TIG) for automatically generating invariant and proof scaffolding
- Examples of timing proofs
    + Data Structures and Algorithms
        * Array: linear search, bubble sort
        * Linked List: linear search, insert at position, WIP insert in sorted list
    + FreeRTOS
        * lists.c: all functions (WIP vInsertList)
        * tasks.c: notably vTaskSwitchContext, some others
        * queue.c: a few functions
    + Cryptography
        * ChaCha20 (handwritten version and MIT PLV version)
        * passwordCheck CVE (vulnerable version and patched safe version)
        * ct-swap (constant-time swap routine from paper)
- Comparisons of proof predictions to real executions
    + DSA proofs

## System Overview
We utilize Linear Temporal Logic as the foundation for timing proofs.
Given a function `toi : instruction -> arguments -> N` that defines the time of an instruction given its arguments, we map toi over a program trace to get a list of cycle counts for the instructions in the trace. Summing the list, we get the total number of clock cycles taken by a program from one point of execution to another. This operation is called `cycle_count_of_trace : trace -> N` or `ccot`.

The Picinae system allows users to specify correctness of programs with respect to any trace `t` that begins at a program entry point and ends at a program exit point.
This allows us to verify the timing of a program by reasoning about `ccot t`.
As a result, the primary postcondition of a Picinae timing proof states `ccot t = f(x0 ... xn)` where `t` is any complete program trace for the targeted program, and `x{i}` is a numeric expression optionally parametrized by a CPU state value, typically the state of the program at entry.
A timing postcondition can then be used to predict the exact timing behavior of a program without running it. This allows for:
- the discovery of timing attack vulnerabilities (if x{i} is parametrized by a secret value v, then an attacker can reconstruct v by measuring the execution time of the program)
- construction of tighter real-time systems: because postconditions typically provide equalities, and WCET analysis provides overapproximations of upper bounds, a real-time system with timing guarantees can allot less time between function calls as they don't have to account for an overapproximation

## Example

The PTM is implemented as a hierarchy of modules and module types the describe CPU behavior, program information, lemmas and definitions regarding timing, and proof tactics.
Let's explore the hierarchy starting from the user's point of view (a proof) and tracing the dependencies backwards.
We'll be looking at a timing proof for a simple program that adds two numbers in a loop, which will serve as an example for timing proof style as well.
After walking through the proof at a high level, we'll explore the dependencies.

Every timing proof is a functor. Timing proof functors take in a CPU description as input. That way, you write your proof with no specific knowledge of any one CPU. Then, you can instantiate the proof module with a specific CPU description and get a timing guarantee that is specific to your CPU of choice for free.

When the user begins a timing proof, they will write a standard header section to set up their environment:

```coq
Module Program_addloop <: ProgramInformation.
    Definition entry_addr : N := 0x8.

    Definition exits (t:trace) : bool :=
        match t with (Addr a,_)::_ => match a with
        | 0x20 => true
        | _ => false
    end | _ => false end.

    (* This definition is auto-generated by a lifter script *)
    Definition binary (a : addr) : N :=
        match a with
        | 0x8  => 0x00106393 (* ori     t2,zero,1 *)
        | 0xc  => 0x000e7e13 (* andi	t3,t3,0 *)
        | 0x10 => 0x01c28863 (* beq	t0,t3,20 <end> *)
        | 0x14 => 0x00130313 (* addi	t1,t1,1 *)
        | 0x18 => 0x407282b3 (* sub	t0,t0,t2 *)
        | 0x1c => 0xffce0ae3 (* beq	t3,t3,10 <add> *)
        | _ => 0 
        end.
End Program_addloop.

Module RISCVTiming := RISCVTiming cpu Program_addloop.
Module addloopAuto := RISCVTimingAutomation RISCVTiming.
Import Program_addloop addloopAuto.
```

Let's go through line by line.

- `Module TimingProof (cpu: RVCPUTimingBehavior).`
  Begins the timing proof functor, taking cpu as an input
- `Module Program_addloop <: ProgramInformation.`
  Begin the ProgramInformation module for the target program
- `Definition entry_addr : N := ...`
  Defines the entry address for the program
- `Definition exits (t:trace) : bool := ...`
  Defines the exit addresses for the program
- `Definition binary :=`
  Defines the function that takes an address and returns an encoded RISC-V instruction. Notice that if registers `t0` and `t1` contain values `x` and `y` at entry, this program should loop `x` times - this will be important later!
- `Module RISCVTiming := RISCVTiming cpu Program_addloop.`
  Instantiates the RISCVTiming module for the provided cpu and program, this defines a `time_of_instruction` function and provides definitions designating the time of a specific instruction
- `Module addloopAuto := RISCVTimingAutomation RISCVTiming.`
  Instantiates the RISCVTimingAutomation module for the provided cpu and program, this defines `cycle_count_of_trace` and provides automation tactics and lemmas
- `Import Program_addloop addloopAuto.`
  Imports all of the definitions from the instantiated modules into the context

Now that the context is set up, we need to define our *invariant set*, the set of propositions that describe the program's behavior throughout its execution.

```coq
Definition addloop_timing_invs (x y : N) (t:trace) :=
match t with (Addr a, s) :: t' => match a with
    | 0x8  => Some (s R_T0 = x /\ s R_T1 = y /\
        cycle_count_of_trace t' = 0)
    | 0x10 => Some (s R_T2 = 1 /\ s R_T3 = 0 /\ 
        s R_T0 <= x /\
        cycle_count_of_trace t' = 
            tori + tandi + (x - s R_T0) * (tfbeq + taddi + tsub + ttbeq))
    | 0x20 => Some (cycle_count_of_trace t' = 
            tori + tandi + x * (tfbeq + taddi + tsub + ttbeq) + ttbeq)
    | _ => None end
| _ => None
end.
```

Notice that our invariant set is parametrized by `x` and `y` - the input values to the `addloop` program.
Now let's investigate the invariants:

1. The invariant at address `0x8`, our invariant address, simply tracks important register contents and the fact that no time has passed yet (`cycle_count_of_trace t' = 0`)
2. The invariant at address `0x10` describes the state of the program at the beginning of each loop iteration. Notably, we know that `t0` has not yet surpassed the initial value `x`, and we can see that the time that's passed is equal to `<time of setup instructions> + <# of loop iterations> * <length of loop body>` where `# of loop iterations` is equal to `x - t0` (convince yourself why this is always true)
3. The invariant at address `0x20` is the postcondition, and we can clearly see that the loop is stated to iterate `x` times


In short, we construct timing invariants that describe the intermediate time of a program at certain points during execution.
Sometimes these invariants will need to track propositions regarding program correctness. This can be seen in the invariants regarding the values of register contents, but this is a mild case.

But these are just statements. Let's look at a timing proof now:

```coq
Theorem addloop_timing:
  forall s t s' x' x y
         (* Define the entry point of the function *)
         (ENTRY: startof t (x',s') = (Addr entry_addr,s))
         (MDL: models rvtypctx s)
         (T0: s R_T0 = x)        (* Tie the contents of T0 to x *)
         (T1: s R_T1 = y),       (* Tie the contents of T1 to y *)
  satisfies_all 
    lifted_prog                  (* Lifted code generated by RISCVTiming *)
    (addloop_timing_invs x y)    (* Invariant set *)
    exits                        (* Exit point *)
  ((x',s')::t).
```

This theorem states that all of our invariants are satisfied for all program traces that start at `entry_addr` and end at one of the `exits`.

We'll prove this theorem by proving a few cases:

1. The base case - given the above theorem assumptions, prove the invariant at `0x8`
2. The loop entry case - given invariant `0x8` as an assumption, prove the invariant at `0x10`
3. The loop exit case - given invariant `0x10` as an assumption, prove the postcondition at `0x20`
4. The loop iteration case - given invariant `0x8` as an assumption, prove that the invariant at `0x8` holds after any one loop iteration

For this proof, the majority of the work here is done by the `hammer` tactic, which seeks to prove goals of the form `cycle_count_of_trace t = ...`.

Here's the proof in its entirety:

```coq
Proof.
    intros.
    apply prove_invs.
    Local Ltac step := tstep r5_step.

    (* Case 1 *)
    simpl. rewrite ENTRY. step.
    split.
        assumption.
    split.
        assumption.
    hammer.

    (* Boilerplate *)
    intros.
    eapply startof_prefix in ENTRY; try eassumption.
    eapply preservation_exec_prog in MDL; try (eassumption || apply lift_riscv_welltyped).
    clear - PRE MDL. rename t1 into t. rename s1 into s'.
    destruct_inv 32 PRE.

    (* Case 2 *)
    destruct PRE as [T0 [T2 Cycles]].
    repeat step. repeat split; try assumption. lia. 
    hammer.

    (* Addr 0x10 *)
    destruct PRE as [T2 [T3 [T0 Cycles_t]]].
    step.
    - (* Case 3: t0 = 0 -> postcondition *)
        hammer.
    - (* Case 4: t0 <> 0 -> loop again *)
        step. step. step.
        rewrite msub_nowrap by (psimpl; lia).
        repeat split.
            lia.
        hammer. rewrite N_sub_distr; lia.
Qed.
```

Finally, close the timing proof module:

```coq
End TimingProof.
```

And that's it!

## System Implementation

Now let's look at the module hierarchy.
