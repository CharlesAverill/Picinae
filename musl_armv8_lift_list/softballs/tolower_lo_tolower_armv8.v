(* Generated by pcode2coq.py + ixb's own hands
arch: armv8
file: tolower.lo
function: tolower
*)

Require Import Picinae_armv8.
Require Import NArith.
Require Import Lia.
Open Scope N.

Definition tolower_lo_tolower_armv8 : program := fun _ a => match a with

(* 0x00200000: sub w1,w0,#0x41 *)
| 2097152 => Some (4,
    Move (V_TEMP 249216) (BinOp OP_MINUS (Extract 31 0 (Var R_X0)) (Word 65 32)) $;
    Move R_X1 (Cast CAST_UNSIGNED 64 (Var (V_TEMP 249216)))
)

(* 0x00200004: cmp w1,#0x19 *)
| 2097156 => Some (4,
    Move (V_TEMP 117120) (Word 25 32) $;
    Move R_TMPCY (Cast CAST_UNSIGNED 8 (BinOp OP_LE (Word 25 32) (Extract 31 0 (Var R_X1)))) $;
    Move R_TMPOV (Cast CAST_LOW 8 (BinOp OP_AND (BinOp OP_XOR (BinOp OP_AND (BinOp OP_RSHIFT (Extract 31 0 (Var R_X1)) (Word 31 32)) (Word 1 32)) (BinOp OP_AND (BinOp OP_RSHIFT (BinOp OP_MINUS (Extract 31 0 (Var R_X1)) (Word 25 32)) (Word 31 32)) (Word 1 32))) (BinOp OP_XOR (BinOp OP_XOR (BinOp OP_AND (BinOp OP_RSHIFT (BinOp OP_MINUS (Extract 31 0 (Var R_X1)) (Word 25 32)) (Word 31 32)) (Word 1 32)) (BinOp OP_AND (BinOp OP_RSHIFT (Word 25 32) (Word 31 32)) (Word 1 32))) (Word 1 32)))) $;
    Move (V_TEMP 117376) (BinOp OP_MINUS (Extract 31 0 (Var R_X1)) (Var (V_TEMP 117120))) $;
    Move R_TMPNG (Cast CAST_UNSIGNED 8 (BinOp OP_SLT (Var (V_TEMP 117376)) (Word 0 32))) $;
    Move R_TMPZR (Cast CAST_UNSIGNED 8 (BinOp OP_EQ (Var (V_TEMP 117376)) (Word 0 32))) $;
    Move R_NG (Var R_TMPNG) $;
    Move R_ZR (Var R_TMPZR) $;
Move R_CY (Var R_TMPCY) $;
    Move R_OV (Var R_TMPOV)
)

(* 0x00200008: b.hi 0x00200010 *)
| 2097160 => Some (4,
    Move (V_TEMP 3456) (UnOp OP_NOT (Var R_ZR)) $;
    Move (V_TEMP 3712) (BinOp OP_AND (Var R_CY) (Var (V_TEMP 3456))) $;
    If (Cast CAST_LOW 1 (Var (V_TEMP 3712))) (
        Jmp (Word 2097168 64)
    ) (* else *) (
        Nop
    )
)

(* 0x0020000c: orr w0,w0,#0x20 *)
| 2097164 => Some (4,
    Move (V_TEMP 184064) (BinOp OP_OR (Extract 31 0 (Var R_X0)) (Word 32 32)) $;
    Move R_X0 (Cast CAST_UNSIGNED 64 (Var (V_TEMP 184064)))
)

(* 0x00200010: ret *)
| 2097168 => Some (4,
    Move R_PC (Var R_X30) $;
    Jmp (Var R_PC)
)

| _ => None
end.

Theorem welltyped: welltyped_prog arm8typctx tolower_lo_tolower_armv8. Proof. Picinae_typecheck. Qed.

Definition Init (t:trace) s xs' x0 :=
  startof t xs' = (Addr 2097152, s)
  /\ models arm8typctx s
  /\ s R_X0 = x0.

Section Invs.

  Variable x0 : N.

  Require Import Bool.

  Definition w0 := x0 mod 2 ^ 32.
  Definition postcondition (n:N) : Prop := 
    if (65 <=? w0) && (w0 <=? 90) then n = w0 + 32 else n = x0.

  Definition Invs (t:trace) : option Prop :=
    match t with (Addr a, s)::_ =>
      match a with
      | 2097152 => Some (s R_X0 = x0)
      | 2097168 => Some (postcondition (s R_X0))
      | _ => None
      end
    | _ => None end.


End Invs.


Definition exit (t:trace) : bool :=
  match t with (Addr a, _)::_ =>
    match a with
      2097168 => true
    | _ => false
    end
  | _ => false
  end.

Lemma and_gte_to_or_gte : forall n x, (n <=? x) = ((n <? x) || (n =? x))%bool.
  Proof.
  intros. destruct (n <=? x) eqn:LE. rewrite N.leb_le in LE.
  symmetry. rewrite Bool.orb_true_iff. rewrite N.ltb_lt. 
  rewrite N.eqb_eq. rewrite <- N.le_lteq. apply LE. rewrite N.leb_gt in LE.
  symmetry. rewrite Bool.orb_false_iff. rewrite N.ltb_ge. rewrite N.eqb_neq.
  rewrite N.le_neq in LE. split; destruct LE. try assumption.
  symmetry. assumption.
   Qed.

Theorem tolower_partial_correctness :
  forall s t xs' x0 (INIT: Init t s xs' x0),
    satisfies_all tolower_lo_tolower_armv8 (Invs x0) exit (xs'::t).
Proof.
  intros s t xs' x0 INIT. destruct INIT as (ENTRY & MDL & R2).
  apply prove_invs.

  (* Base Case *)
  simpl. rewrite ENTRY. arm8_step. assumption.

  (* Inductive Case *)
  intros.
  eapply startof_prefix in ENTRY; try eassumption.
  eapply preservation_exec_prog in MDL; try (eassumption || apply welltyped).
  clear - PRE MDL. rename t1 into t; rename s1 into s.
  destruct_inv 64 PRE.

  assert((if x0 mod 2 ^ 32 =? 90 then 0 else 1) = if negb (x0 mod 2 ^ 32 =? 90) then 1 else 0) as to_and.
  symmetry. apply Bool.if_negb.

  arm8_step. arm8_step. arm8_step. arm8_step.

  rewrite to_and in BC.
  rewrite <- Bool.andb_if in BC.

-  
   destruct ((25 <=? msub 32 x0 65) && negb (x0 mod 2 ^ 32 =? 90))%bool eqn:main. 
   discriminate BC. clear BC.
   rewrite Bool.andb_false_iff in main.
   destruct main.
   
   rewrite N.leb_gt in H.
   rewrite <- msub_lt_iff in H. 
   replace (65 mod 2 ^ 32 + 25) with 90 in H by reflexivity.
   replace (65 mod 2 ^ 32) with 65 in H by reflexivity.
   destruct H. apply N.lt_le_incl in H.
   rewrite <- N.leb_le in H. unfold w0. rewrite H. 
   rewrite Bool.andb_true_r.
   destruct H0. rewrite <- N.leb_le in H0. rewrite H0.
    
   rewrite N.add_comm. remember (x0 mod 2 ^ 32) as x. destruct x as [|x]; 
   try reflexivity. repeat (discriminate || reflexivity || destruct x as [x|x|]).
   rewrite N.leb_le in H.
   remember (x0 mod 2 ^ 32) as x.
   rewrite N.lt_add_lt_sub_l in H0. simpl in H0.
   lia. rewrite Bool.negb_false_iff in H.
   rewrite N.eqb_eq in H. unfold w0.
   rewrite H. reflexivity.

-  rewrite to_and in BC; rewrite <- Bool.andb_if in BC. 
   destruct ((25 <=? msub 32 x0 65) && negb (x0 mod 2 ^ 32 =? 90))%bool eqn:main.
   clear BC. rewrite Bool.andb_true_iff in main.
   destruct main. rewrite Bool.negb_true_iff in H0. rewrite N.leb_le in H.
   apply le_msub_iff in H. 
   replace (65 mod 2 ^ 32 + 25) with 90 in H by reflexivity.
   replace (65 mod 2 ^ 32) with 65 in H by reflexivity.
 destruct H.
   rewrite N.eqb_neq in H0. apply not_eq_sym in H0.
   assert(90 <= x0 mod 2 ^ 32 /\ 90 <>  x0 mod 2 ^ 32). split. apply H. apply H0.
   clear H0 H. rewrite <- N.le_neq in H1.
   destruct (w0 x0 <=? 90) eqn:x90. rewrite N.leb_le in x90. apply N.le_ge in x90. unfold w0 in x90.
   contradiction. rewrite Bool.andb_false_r. reflexivity. destruct H. rewrite <- N.le_sub_le_add_l in H1.
   assert(90 - 2^32 = 0) as eq0. reflexivity. rewrite eq0 in H1. clear eq0. rewrite <- N.leb_gt in H.
   unfold w0. rewrite H. rewrite Bool.andb_false_l. reflexivity. discriminate.
   Qed. 
