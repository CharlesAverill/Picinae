(* Generated by pcode2coq.py
arch: armv8
file: islower.lo
function: islower
*)
Require Import Lia.

Require Import Picinae_armv8.
Require Import NArith.
Open Scope N.

Definition islower_lo_islower_armv8 : program := fun _ a => match a with

(* 0x00100000: sub w0,w0,#0x61 *)
| 1048576 => Some (4,
	Move (V_TEMP 249216) (BinOp OP_MINUS (Extract 31 0 (Var R_X0)) (Word 97 32)) $;
	Move R_X0 (Cast CAST_UNSIGNED 64 (Var (V_TEMP 249216)))
)

(* 0x00100004: cmp w0,#0x19 *)
| 1048580 => Some (4,
	Move (V_TEMP 117120) (Word 25 32) $;
	Move R_TMPCY (Cast CAST_UNSIGNED 8 (BinOp OP_LE (Word 25 32) (Extract 31 0 (Var R_X0)))) $;
	Move R_TMPOV (Cast CAST_LOW 8 (BinOp OP_AND (BinOp OP_XOR (BinOp OP_AND (BinOp OP_RSHIFT (Extract 31 0 (Var R_X0)) (Word 31 32)) (Word 1 32)) (BinOp OP_AND (BinOp OP_RSHIFT (BinOp OP_MINUS (Extract 31 0 (Var R_X0)) (Word 25 32)) (Word 31 32)) (Word 1 32))) (BinOp OP_XOR (BinOp OP_XOR (BinOp OP_AND (BinOp OP_RSHIFT (BinOp OP_MINUS (Extract 31 0 (Var R_X0)) (Word 25 32)) (Word 31 32)) (Word 1 32)) (BinOp OP_AND (BinOp OP_RSHIFT (Word 25 32) (Word 31 32)) (Word 1 32))) (Word 1 32)))) $;
	Move (V_TEMP 117376) (BinOp OP_MINUS (Extract 31 0 (Var R_X0)) (Var (V_TEMP 117120))) $;
	Move R_TMPNG (Cast CAST_UNSIGNED 8 (BinOp OP_SLT (Var (V_TEMP 117376)) (Word 0 32))) $;
	Move R_TMPZR (Cast CAST_UNSIGNED 8 (BinOp OP_EQ (Var (V_TEMP 117376)) (Word 0 32))) $;
	Move R_NG (Var R_TMPNG) $;
	Move R_ZR (Var R_TMPZR) $;
	Move R_CY (Var R_TMPCY) $;
	Move R_OV (Var R_TMPOV)
)

(* 0x00100008: cset w0,ls *)
| 1048584 => Some (4,
	Move (V_TEMP 10240) (UnOp OP_NOT (Var R_CY)) $;
	Move (V_TEMP 10496) (BinOp OP_OR (Var (V_TEMP 10240)) (Var R_ZR)) $;
	Move R_X0 (Cast CAST_UNSIGNED 64 (Var (V_TEMP 10496)))
)

(* 0x0010000c: ret *)
| 1048588 => Some (4,
	Move R_PC (Var R_X30) $;
	Jmp (Var R_PC)
)

| _ => None
end.

Theorem welltyped: welltyped_prog arm8typctx islower_lo_islower_armv8. Proof. Picinae_typecheck. Qed.

Definition Init (t:trace) s xs' x0 :=
  startof t xs' = (Addr 1048576, s)
  /\ models arm8typctx s
  /\ s R_X0 = x0.

Section Invs.

  Variable x0 : N.

  Definition w0 := x0 mod 2 ^ 32.
  Require Import Bool.
  (* Note this isn't proper Rocq code, change it so the condition is computable. *)
  Definition postcondition (n:N) : Prop :=
    (if (97 <=? w0) && (w0 <=? 122) then n = 255 else n = 254).

  Definition Invs (t:trace) : option Prop :=
    match t with (Addr a, s)::_ =>
      match a with
      | 1048576 => Some (s R_X0 = x0)
      | 1048588 => Some (postcondition (s R_X0))
      | _ => None
      end
    | _ => None end.
  

End Invs.


Definition exit (t:trace) : bool :=
  match t with (Addr a, _)::_ =>
    match a with
      1048588 => true
    | _ => false
    end
  | _ => false
  end.

Theorem islower_partial_correctness :
  forall s t xs' x0 (INIT: Init t s xs' x0),
    satisfies_all islower_lo_islower_armv8 (Invs x0) exit (xs'::t).
Proof.
  intros s t xs' x0 INIT. destruct INIT as (ENTRY & MDL & R2).
  apply prove_invs.

  (* Base Case *)
  simpl. rewrite ENTRY. arm8_step. assumption.

  (* Inductive Case *)
  intros.
  eapply startof_prefix in ENTRY; try eassumption.
  eapply preservation_exec_prog in MDL; try (eassumption || apply welltyped).
  clear - PRE MDL. rename t1 into t; rename s1 into s.
  destruct_inv 64 PRE.

  (*helpers*)
  assert (97 mod 2 ^ 32 + 25 = 122) as helper1.
    reflexivity.

  assert (97 mod 2 ^ 32 = 97) as helper2.
  reflexivity.

  assert(forall n x, (n <=? x) = ((n <? x) || (n =? x)))%bool as neq_sym.
  intros. destruct (n <=? x) eqn:whatever. rewrite N.leb_le in whatever.
  symmetry. rewrite Bool.orb_true_iff. rewrite N.ltb_lt. 
  rewrite N.eqb_eq. rewrite <- N.le_lteq. apply whatever. rewrite N.leb_gt in whatever.
  symmetry. rewrite Bool.orb_false_iff. rewrite N.ltb_ge. rewrite N.eqb_neq.
  rewrite N.le_neq in whatever. assert (n <> x <-> x <> n).
  split. symmetry. apply H. symmetry. apply H.
  rewrite H. apply whatever.

  (*helpers*)

  arm8_step. arm8_step. arm8_step.
  
  assert(N.lor 255 (if x0 mod 2 ^ 32 =? 122 then 1 else 0) = 255 /\
        N.lor (if 25 <=? msub 32 x0 97 then 254 else 255) 1 = 255).
    split. destruct (x0 mod 2 ^ 32 =? 122); reflexivity.
    destruct (25 <=? msub 32 x0 97); reflexivity.
    destruct H as [or1 or2].


  assert (((w0 x0 <? 122) && (97 <=? w0 x0))%bool = true -> 25 <=? msub 32 x0 97 = false) as msub_not.
    intros rang. rewrite N.leb_nle. rewrite <- le_msub_iff. unfold not. intros hyp. rewrite helper1 in hyp. rewrite helper2 in hyp.
  - symmetry in rang. destruct hyp; apply Bool.andb_true_eq in rang;
    destruct rang as [upper lower]; apply eq_sym in upper; apply eq_sym in lower;
    rewrite N.ltb_lt in upper; rewrite N.leb_le in lower; apply N.lt_gt in upper;
    try contradiction. destruct H. apply N.lt_gt in H.
    contradiction.
    
  - assert(((97 <=? w0 x0) && (w0 x0 <=? 122))%bool = 
    ((97 <=? w0 x0) && ((w0 x0 <? 122) || (w0 x0 =? 122))%bool)%bool).
    rewrite <- neq_sym. reflexivity.

   rewrite H. destruct ((97 <=? w0 x0) && ((w0 x0 <? 122) || (w0 x0 =? 122)))%bool eqn:main.
   destruct (w0 x0 =? 122) eqn:eq_upper. rewrite Bool.orb_true_r in main.
   rewrite Bool.andb_true_r in main. unfold w0 in eq_upper.
   rewrite eq_upper. apply or2. rewrite Bool.orb_false_r in main.
   rewrite Bool.andb_comm in main. apply msub_not in main. rewrite main. apply or1.

   rewrite Bool.andb_false_iff in H. destruct H.


   assert((97 <=? w0 x0) = false -> 25 <=? msub 32 x0 97 = true) as msub_yes1. 
   intros rang. rewrite N.leb_gt in rang. rewrite N.leb_le.
   rewrite <- le_msub_iff. rewrite helper1. rewrite helper2.
   right. split. unfold w0. apply rang. rewrite <- N.le_sub_le_add_l.
   assert (122 - 2 ^32 = 0)as eq_zer0. reflexivity. rewrite eq_zer0.
   apply N.le_0_l. rewrite msub_yes1. rewrite N.leb_gt in H. unfold w0 in H. 
   destruct (x0 mod 2 ^ 32 =? 122) eqn:skibidi. rewrite N.eqb_eq in skibidi. lia.
  reflexivity. apply H. 

  assert((w0 x0 <=? 122) = false -> 25 <=? msub 32 x0 97 = true) as msub_yes2.  
  intros rang. rewrite N.leb_gt in rang. 
  rewrite N.leb_le. rewrite <- le_msub_iff. rewrite helper1. rewrite helper2.
  left. apply N.lt_le_incl in rang. unfold w0 in rang. apply rang.
  rewrite msub_yes2. destruct (x0 mod 2 ^ 32 =? 122) eqn:skibidi.
  rewrite N.eqb_eq in skibidi. rewrite N.leb_gt in H. unfold w0 in H. lia. 
  reflexivity. apply H.
   Qed.
