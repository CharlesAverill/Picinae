(* Generated by pcode2coq.py
arch: armv8
file: toupper.lo
function: toupper
*)

Require Import Picinae_armv8.
Require Import NArith.
Require Import Lia.
Open Scope N.

Definition toupper_lo_toupper_armv8 : program := fun _ a => match a with

(* 0x00100000: sub w1,w0,#0x61 *)
| 1048576 => Some (4,
	Move (V_TEMP 249216) (BinOp OP_MINUS (Extract 31 0 (Var R_X0)) (Word 97 32)) $;
	Move R_X1 (Cast CAST_UNSIGNED 64 (Var (V_TEMP 249216)))
)

(* 0x00100004: cmp w1,#0x19 *)
| 1048580 => Some (4,
	Move (V_TEMP 117120) (Word 25 32) $;
	Move R_TMPCY (Cast CAST_UNSIGNED 8 (BinOp OP_LE (Word 25 32) (Extract 31 0 (Var R_X1)))) $;
	Move R_TMPOV (Cast CAST_LOW 8 (BinOp OP_AND (BinOp OP_XOR (BinOp OP_AND (BinOp OP_RSHIFT (Extract 31 0 (Var R_X1)) (Word 31 32)) (Word 1 32)) (BinOp OP_AND (BinOp OP_RSHIFT (BinOp OP_MINUS (Extract 31 0 (Var R_X1)) (Word 25 32)) (Word 31 32)) (Word 1 32))) (BinOp OP_XOR (BinOp OP_XOR (BinOp OP_AND (BinOp OP_RSHIFT (BinOp OP_MINUS (Extract 31 0 (Var R_X1)) (Word 25 32)) (Word 31 32)) (Word 1 32)) (BinOp OP_AND (BinOp OP_RSHIFT (Word 25 32) (Word 31 32)) (Word 1 32))) (Word 1 32)))) $;
	Move (V_TEMP 117376) (BinOp OP_MINUS (Extract 31 0 (Var R_X1)) (Var (V_TEMP 117120))) $;
	Move R_TMPNG (Cast CAST_UNSIGNED 8 (BinOp OP_SLT (Var (V_TEMP 117376)) (Word 0 32))) $;
	Move R_TMPZR (Cast CAST_UNSIGNED 8 (BinOp OP_EQ (Var (V_TEMP 117376)) (Word 0 32))) $;
	Move R_NG (Var R_TMPNG) $;
	Move R_ZR (Var R_TMPZR) $;
	Move R_CY (Var R_TMPCY) $;
	Move R_OV (Var R_TMPOV)
)

(* 0x00100008: b.hi 0x00100014 *)
| 1048584 => Some (4,
	Move (V_TEMP 3456) (UnOp OP_NOT (Var R_ZR)) $;
	Move (V_TEMP 3712) (BinOp OP_AND (Var R_CY) (Var (V_TEMP 3456))) $;
	If (Cast CAST_LOW 1 (Var (V_TEMP 3712))) (
		Jmp (Word 1048596 64)
	) (* else *) (
		Nop
	)
)

(* 0x0010000c: mov w1,#0x5f *)
| 1048588 => Some (4,
	Move R_X1 (Word 95 64)
)

(* 0x00100010: and w0,w0,w1 *)
| 1048592 => Some (4,
	Move (V_TEMP 75904) (BinOp OP_AND (Extract 31 0 (Var R_X0)) (Extract 31 0 (Var R_X1))) $;
	Move R_X0 (Cast CAST_UNSIGNED 64 (Var (V_TEMP 75904)))
)

(* 0x00100014: ret *)
| 1048596 => Some (4,
	Move R_PC (Var R_X30) $;
	Jmp (Var R_PC)
)

| _ => None
end.

Theorem welltyped: welltyped_prog arm8typctx toupper_lo_toupper_armv8. Proof. Picinae_typecheck. Qed.

Definition Init (t:trace) s xs' x0 :=
  startof t xs' = (Addr 1048576, s)
  /\ models arm8typctx s
  /\ s R_X0 = x0.

Section Invs.

  Variable x0 : N.

  Require Import Bool.

  Definition w0 := x0 mod 2 ^ 32.

  Definition postcondition (n:N) : Prop := 
    if (97 <=? w0) && (w0 <=? 122) then n = w0 - 32 else n = x0.

  Definition Invs (t:trace) : option Prop :=
    match t with (Addr a, s)::_ =>
      match a with
      | 1048576 => Some (s R_X0 = x0)
      | 1048596 => Some (postcondition (s R_X0))
      | _ => None
      end
    | _ => None end.


End Invs.


Definition exit (t:trace) : bool :=
  match t with (Addr a, _)::_ =>
    match a with
      1048596 => true
    | _ => false
    end
  | _ => false
  end. 


Lemma max_bit_index : forall x n, N.testbit x n = true -> N.log2 x >= n.
Proof.
  intros x n H; rewrite N.ge_le_iff.
  destruct (N.le_gt_cases n (N.log2 x)) as [H0 | GT]. assumption. exfalso.
  apply N.bits_above_log2 in GT. now rewrite GT in H.
Qed.

Lemma diff_params : forall x n a, N.testbit x n = true ->
  N.testbit x a = false -> n <> a.
Proof.
  intros x n a T F eq. subst. rewrite T in F. discriminate.
Qed.

Lemma mod_false_spec :
  forall a n j, N.testbit a n = false -> N.testbit (a mod 2 ^ j) n = false.
Proof.
  intros. rewrite <-N.land_ones.
  rewrite N.land_spec.
  rewrite N_ones_spec_ltb. rewrite H.
  rewrite Bool.andb_false_l. reflexivity.
Qed.

Fact main_proof: forall x0, (x0 mod 2 ^ 32 <=? 122) = true -> (97 <=? x0 mod 2 ^ 32) = true ->
  N.land x0 95 = x0 mod 2 ^ 32 - 32.
Proof.
  assert (forall x0 a, (x0 mod 2 ^ 32 <=? 122) = true -> (97 <=? x0 mod 2 ^ 32) = true ->
  a <= 6 -> a <> 5 ->
 N.testbit(x0 mod 2 ^ 32 - 32) a = N.testbit(x0 mod 2 ^ 32) a) as x032same.
  
  intros. remember(x0 mod 2 ^ 32) as x. 
  destruct x as [|x];
      try reflexivity; repeat (discriminate || lia || reflexivity || destruct x as [x|x|] ||
  destruct a as [|a];
      try reflexivity; repeat (lia || reflexivity || destruct a as [a|a|])).

  assert (forall x0 a, (x0 mod 2 ^ 32 <=? 122) = true -> (97 <=? x0 mod 2 ^ 32) = true ->
  N.testbit (x0 mod 2 ^ 32) a = false -> N.testbit (x0 mod 2 ^ 32 - 32) a = false) as x_same_x_mod_false_32.

  intros. remember (x0 mod 2 ^ 32) as x.
  assert(N.log2 x < a -> N.testbit x a = false).
  apply N.bits_above_log2.
  destruct x as [|x];
      try reflexivity; repeat (discriminate || reflexivity || destruct x as [x|x|] ||
  destruct a as [|a];
      try reflexivity; repeat (lia || reflexivity || destruct a as [a|a|])).

  assert (forall x0 a, N.testbit (N.land x0 95) a = true -> 6 >= a /\ a <> 5) as land95_true.
    intros. rewrite N.land_spec in H.
    rewrite Bool.andb_true_iff in H. destruct H. split. apply max_bit_index in H0. 
    simpl in H0; try assumption. apply diff_params with (a:=5) in H0. apply H0.
    reflexivity.

  intros x0 HI LO. apply N.bits_inj. unfold N.eqf. intros n.
  destruct (N.testbit (N.land x0 95) n) eqn:H. 
  assert (N.testbit (N.land x0 95) n = true) as H0. apply H. 
  apply land95_true in H. destruct H. rewrite x032same; try lia; try assumption. 
   rewrite N.land_spec in H0. rewrite Bool.andb_true_iff in H0. destruct H0. 
   rewrite N.mod_pow2_bits_low; try assumption; try lia. symmetry. apply H0. symmetry. rewrite N.land_spec in H. 
   rewrite Bool.andb_false_iff in H. destruct H. 
   apply mod_false_spec with (j:= 32) in H. apply x_same_x_mod_false_32 in H; assumption.
  remember (x0 mod 2 ^ 32) as x.
  destruct x as [|x];
      try reflexivity; repeat (discriminate || reflexivity || destruct x as [x|x|] ||
  destruct n as [|n];
      try reflexivity; repeat (lia || reflexivity || destruct n as [n|n|])).
Qed.

Lemma and_gte_to_or_gte : forall n x, (n <=? x) = ((n <? x) || (n =? x))%bool.
  Proof.
  intros. destruct (n <=? x) eqn:LE. rewrite N.leb_le in LE.
  symmetry. rewrite Bool.orb_true_iff. rewrite N.ltb_lt. 
  rewrite N.eqb_eq. rewrite <- N.le_lteq. apply LE. rewrite N.leb_gt in LE.
  symmetry. rewrite Bool.orb_false_iff. rewrite N.ltb_ge. rewrite N.eqb_neq.
  rewrite N.le_neq in LE. split; destruct LE. try assumption.
  symmetry. assumption.
   Qed.

Lemma even_double_div_iff : forall y, N.even y = true <-> N.double (N.div2 y) = y.
Proof.
  split. intro. destruct y. reflexivity. destruct p; try reflexivity; try discriminate.
  intro. destruct y. reflexivity. destruct p; try reflexivity; try discriminate.
Qed.

Lemma exists_even_mod: forall a b x, x mod (2*b) = 2*a -> exists c, x = 2 * c.
Proof.
  intros a b x H.
  assert (EQ:=N.Div0.div_mod x (2*b)).
  rewrite H in EQ.
  rewrite <-N.mul_assoc in EQ.
  rewrite <-(N.mul_add_distr_l 2 _ a) in EQ.
  eexists. exact EQ. 
Qed.

Lemma even_exists_iff : forall x, N.even x = true <-> exists c, x = 2 * c.
Proof.
  split. intro H. apply even_double_div_iff in H. symmetry in H.
  rewrite N.double_spec in H. exists (N.div2 x). apply H. 
  intro H. destruct H as [c Hc]. rewrite Hc. apply N.even_even.
Qed.

Lemma infer_evenness_mod : forall x y z, N.even y = true -> N.even z = true -> x mod y = z ->
  N.even x = true.
Proof.
  intros x y z Hy Hz Hmod. apply even_double_div_iff in Hy, Hz.  rewrite N.double_spec in Hy, Hz.
  rewrite <- Hy, <- Hz in Hmod. clear Hy Hz. apply exists_even_mod in Hmod. 
  apply even_exists_iff. apply Hmod.
Qed.

Theorem tolower_partial_correctness :
  forall s t xs' x0 (INIT: Init t s xs' x0),
    satisfies_all toupper_lo_toupper_armv8 (Invs x0) exit (xs'::t).
Proof.

  intros s t xs' x0 INIT. destruct INIT as (ENTRY & MDL & R2).
  apply prove_invs.

  (* Base Case *)
  simpl. rewrite ENTRY. arm8_step. assumption.

  (* Inductive Case *)
  intros.
  eapply startof_prefix in ENTRY; try eassumption.
  eapply preservation_exec_prog in MDL; try (eassumption || apply welltyped).
  clear - PRE MDL. rename t1 into t; rename s1 into s.
  destruct_inv 64 PRE.

  assert((if x0 mod 2 ^ 32 =? 122 then 0 else 1) = if negb (x0 mod 2 ^ 32 =? 122) then 1 else 0) as to_and.
  symmetry. apply Bool.if_negb.

  assert (forall n, n mod 2 ^ 32 = 122 -> N.testbit n 0 = false /\ N.testbit n 2 = false) as bit_prop_122.
    intros n H. split. assert(N.even n = true). apply infer_evenness_mod with (y := 2 ^ 32) (z := 122);
    try reflexivity; try assumption. rewrite <-testbit0_even in H0. rewrite Bool.negb_true_iff in H0. 
    assumption. rewrite <- N.land_ones in H. rewrite <- N.bits_inj_iff in H.
    unfold N.eqf in H. specialize(H 2). simpl in H. rewrite N.land_spec in H.
    rewrite Bool.andb_false_iff in H. destruct H. assumption. simpl in H. discriminate.

  assert (forall n, N.testbit 122 n = false -> N.testbit 90 n = false) as _122_false_90_false.
    intros.
    destruct n as [|p].
    reflexivity.
    repeat (reflexivity || lia || (destruct p as [p|p|]; simpl in H)).

  assert (forall n, N.testbit 95 n = false -> N.testbit 90 n = false) as _95_false_90_false.
    intros.
    destruct n as [|p].
    reflexivity.
    repeat (reflexivity || lia || (destruct p as [p|p|]; simpl in H)).

  arm8_step. arm8_step. arm8_step. arm8_step. arm8_step.

  rewrite to_and in BC; rewrite <- Bool.andb_if in BC.

  - destruct ((25 <=? msub 32 x0 97) && negb (x0 mod 2 ^ 32 =? 122))%bool eqn:main. 
   discriminate BC. clear BC.
   rewrite Bool.andb_false_iff in main.
   destruct main as [main1 | main2].
  
   rewrite N.leb_gt in main1.
   rewrite <- msub_lt_iff in main1. replace (97 mod 2 ^ 32 + 25) with 122 in main1 by reflexivity.
   replace (97 mod 2 ^ 32) with 97 in main1 by reflexivity. destruct main1. apply N.lt_le_incl in H.
   rewrite <- N.leb_le in H. unfold w0. rewrite H. 
   rewrite Bool.andb_true_r.
   destruct H0. rewrite <- N.leb_le in H0. rewrite H0.

   apply main_proof; assumption. rewrite N.lt_add_lt_sub_l in H0.
 
   replace (122 - 2 ^ 32) with 0 in H0 by reflexivity. apply N.nlt_0_r in H0. contradiction. 
   rewrite Bool.negb_false_iff in main2. 
   rewrite N.eqb_eq in main2. unfold w0. rewrite main2. simpl.
   rewrite <- N.bits_inj_iff. unfold N.eqf. intros.
   rewrite N.land_spec. destruct (N.testbit x0 n && N.testbit 95 n)%bool eqn:H1; symmetry.
   rewrite Bool.andb_true_iff in H1. destruct H1. 

   assert(N.testbit 95 n = true) as clone; try assumption. apply max_bit_index in clone. simpl in clone.
      destruct n as [|n];
      try reflexivity; repeat (discriminate || reflexivity || lia || destruct n as [n|n|]).
      apply bit_prop_122 in main2; destruct main2; rewrite H1 in H; discriminate. 
      apply bit_prop_122 in main2; destruct main2; rewrite H2 in H; discriminate. 
      rewrite Bool.andb_false_iff in H1. destruct H1. apply mod_false_spec with (j:= 32) in H.
      rewrite main2 in H. apply _122_false_90_false in H. assumption. apply _95_false_90_false in H.
      assumption. 
  
  -   
    rewrite to_and in BC.
    rewrite <- Bool.andb_if in BC. clear to_and.

   destruct ((25 <=? msub 32 x0 97) && negb (x0 mod 2 ^ 32 =? 122))%bool eqn:main. 
   clear BC. rewrite Bool.andb_true_iff in main. destruct main. rewrite Bool.negb_true_iff in H0. 
   rewrite N.leb_le in H. rewrite N.eqb_neq in H0.
   rewrite <- le_msub_iff in H. replace (97 mod 2 ^ 32 + 25) with 122 in H by reflexivity.
   replace (97 mod 2 ^ 32) with 97 in H by reflexivity. destruct H.
   rewrite <- N.leb_le in H. unfold w0. rewrite and_gte_to_or_gte in H. 
   rewrite Bool.orb_true_iff in H. destruct H.
   rewrite N.ltb_lt in H. rewrite <- N.leb_gt in H.
   rewrite H. rewrite Bool.andb_false_r. reflexivity.
   apply Neqb_ok in H. symmetry in H. contradiction. destruct H.
   rewrite <- N.leb_gt in H. unfold w0. rewrite H.
   rewrite Bool.andb_false_l. reflexivity. discriminate BC.
   Qed. 
